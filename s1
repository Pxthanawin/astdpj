local CollectionService = game:GetService("CollectionService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer or Players.PlayerAdded:Wait()
local leaderstats = LocalPlayer:WaitForChild("leaderstats")
local Sheckles = leaderstats:WaitForChild("Sheckles")
local Backpack = LocalPlayer:WaitForChild("Backpack")

local Modules = ReplicatedStorage:WaitForChild("Modules")
local Data = ReplicatedStorage:WaitForChild("Data")

local DataService = require(Modules:WaitForChild("DataService"))
local CountDictionary = require(Modules:WaitForChild("CountDictionary"))
local SeedData = require(Data:WaitForChild("SeedData"))
local GrowableData = require(Data:WaitForChild("GrowableData"))

local myFarm
repeat
    task.wait(1)
    for _, Farm in ipairs(workspace.Farm:GetChildren()) do
        if Farm:FindFirstChild("Important") and Farm.Important:FindFirstChild("Data") and Farm.Important.Data:FindFirstChild("Owner") and Farm.Important.Data.Owner.Value == LocalPlayer.Name then
            myFarm = Farm
            break
        end
    end
until myFarm

local tppoint = {
    Garden = myFarm.Spawn_Point.Position,
    Seed = workspace.Tutorial_Points.Tutorial_Point_1.Position,
    Sell = workspace.Tutorial_Points.Tutorial_Point_2.Position,
    Gear = workspace.Tutorial_Points.Tutorial_Point_3.Position,
    Eggs = workspace.Tutorial_Points.Tutorial_Point_4.Position
}

local plantFruitCache = {}
local plantHaveFruit = function(plant)
    local plantName = plant.Name
    if plantFruitCache[plantName] == nil then
        local plantData = GrowableData.GetDataForPlant(nil, plant)
        plantFruitCache[plantName] = not not (plantData and plantData.GrowFruitTime)
    end
    return plantFruitCache[plantName]
end

local buying = false
local buySeed = function()
    if buying then return end
    buying = true
    while true do
        local money = Sheckles.Value
        local bestSeed
        local getdata = DataService:GetData()
        if not getdata then return end
        local stocks = getdata.SeedStock.Stocks
        for seedname, stockdata in pairs(stocks) do
            --[[if table.find(BuySeeds, seedname) and stockdata.Stock > 0 then
                if money >= SeedData[seedname].Price and (not bestSeed or SeedData[seedname].Price > SeedData[bestSeed].Price) then
                    bestSeed = seedname
                end
            end]]
            if stockdata.Stock > 0 and money >= SeedData[seedname].Price and (not bestSeed or SeedData[seedname].Price > SeedData[bestSeed].Price) then
                bestSeed = seedname
            end
        end
        if bestSeed then
            ReplicatedStorage.GameEvents.BuySeedStock:FireServer(bestSeed)
            task.wait(0.1)
        else
            break
        end
    end
    buying = false
end

local PlantSeed = function(obj)
    local randomPos_D = function()
        local Can_Plant = myFarm.Important.Plant_Locations:GetChildren()[math.random(1,2)]
        local size = Can_Plant.Size
        local pos = Can_Plant.Position

        local halfSizeX = size.X / 2
        local halfSizeZ = size.Z / 2

        local randomX = pos.X + (math.random() * 2 - 1) * halfSizeX
        local randomZ = pos.Z + (math.random() * 2 - 1) * halfSizeZ

        return vector.create(randomX, 0.13552704453468323, randomZ)
    end
    local randomPos_G = function()
        local Can_Plant = myFarm.Important.Plant_Locations:GetChildren()[math.random(1,2)]
        local size = Can_Plant.Size
        local pos = Can_Plant.Position

        local gapWidth = 21
        local sideWidth = (size.X - gapWidth) / 2
        local SidePos = {
            pos - Vector3.new((gapWidth / 2) + (sideWidth / 2), 0, 0),
            pos + Vector3.new((gapWidth / 2) + (sideWidth / 2), 0, 0)
        }

        local chosenSidePos = SidePos[math.random(1,2)]

        local halfSizeX = sideWidth / 2
        local halfSizeZ = size.Z / 2

        local randomX = chosenSidePos.X + (math.random() * 2 - 1) * halfSizeX
        local randomZ = chosenSidePos.Z + (math.random() * 2 - 1) * halfSizeZ

        return vector.create(randomX, 0.13552704453468323, randomZ)
    end

    local Seed = obj:IsA("Tool") and obj:GetAttribute("Seed")
    if not Seed then return end
    LocalPlayer.Character.Humanoid:EquipTool(obj)
    if obj.Parent ~= LocalPlayer.Character and #myFarm.Important.Plants_Physical >= 800 then return end
    LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(tppoint.Garden.X, LocalPlayer.Character.HumanoidRootPart.Position.Y, tppoint.Garden.Z)
    ReplicatedStorage.GameEvents.Plant_RE:FireServer(randomPos_G(), Seed)
    --[[
    LocalPlayer.Character.Humanoid:UnequipTools()
    for _, v in ipairs(Backpack:GetChildren()) do
        local Seed = v:IsA("Tool") and v:GetAttribute("Seed")
        if not Seed then continue end
        if table.find(PlantingSeeds, Seed) then
            LocalPlayer.Character.Humanoid:EquipTool(v)
            while v.Parent == LocalPlayer.Character and #myFarm.Important.Plants_Physical <= 800 do
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(tppoint.Garden.X, LocalPlayer.Character.HumanoidRootPart.Position.Y, tppoint.Garden.Z)
                ReplicatedStorage.GameEvents.Plant_RE:FireServer(randomPos_G(), Seed)
                task.wait(0.1)
            end
        end
    end]]
end
local PlantAllSeed = function()
    LocalPlayer.Character.Humanoid:UnequipTools()
    for _, v in ipairs(Backpack:GetChildren()) do
        PlantSeed(v)
        task.wait(0.1)
    end
end

local CollectPlant = function(model)
    ReplicatedStorage.ByteNetReliable:FireServer(buffer.fromstring("\001\001\000\001"), {model})
end
local autoCollectPlant = function()
    while task.wait(15) do
        local getdata = DataService:GetData()
        if not (getdata and getdata.InventoryData) then return end
        local holdableItems = {}
        for uuid, itemData in pairs(getdata.InventoryData) do
            if itemData.ItemType == "Holdable" then
                holdableItems[uuid] = itemData
            end
        end
        local maxCapacity = 200 + (LocalPlayer:GetAttribute("BonusBackpackSize") or 0)
        local currentCapacity = maxCapacity - CountDictionary(holdableItems)
        if currentCapacity > 0 then
            for _, plant in ipairs(myFarm.Important.Plants_Physical:GetChildren()) do
                if currentCapacity <= 0 then break end
                if plant:FindFirstChild("Grow") and (plant.Grow.Age.Value < plant:GetAttribute("MaxAge")) then continue end
                if plantHaveFruit(plant) then
                    if plant:FindFirstChild("Fruits") then
                        for _, fruit in ipairs(plant.Fruits:GetChildren()) do
                            if fruit:FindFirstChild("Grow") and (fruit.Grow.Age.Value < fruit:GetAttribute("MaxAge")) then continue end
                            CollectPlant(fruit)
                            currentCapacity -= 1
                        end
                    end
                else
                    LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(tppoint.Sell.X, LocalPlayer.Character.HumanoidRootPart.Position.Y, tppoint.Sell.Z)
                    CollectPlant(plant)
                end
            end
        end
        if Sheckles.Value < 10000 then
            ReplicatedStorage.GameEvents.Sell_Inventory:FireServer()
        end
    end
end

if "MAIN" then
    Sheckles.Changed:Connect(buySeed)
    DataService:GetPathSignal("SeedStock"):Connect(function(v)
        if v == 'Stocks' then
            buySeed()
        end
    end)
    task.spawn(buySeed)
    task.spawn(autoCollectPlant)
    task.spawn(PlantAllSeed)
    Backpack.ChildAdded:Connect(PlantSeed)
end

--[[
local function checkInventoryStatus()
    local getdata = DataService:GetData()
    if not (getdata and getdata.InventoryData) then return end

    local holdableItems = {}
    for uuid, itemData in pairs(getdata.InventoryData) do
        if itemData.ItemType == "Holdable" then
            holdableItems[uuid] = itemData
        end
    end

    local currentHoldableCount = CountDictionary(holdableItems)

    local baseCapacity = 200
    local bonusCapacity = LocalPlayer:GetAttribute("BonusBackpackSize") or 0
    local maxCapacity = baseCapacity + bonusCapacity

    print("========================================")
    print("สถานะช่องเก็บของ (ผลผลิต):")
    print(string.format("  - จำนวนปัจจุบัน: %d", currentHoldableCount))
    print(string.format("  - ความจุสูงสุด: %d (เริ่มต้น %d + โบนัส %d)", maxCapacity, baseCapacity, bonusCapacity))
    print(string.format("  - สถานะ: %d / %d", currentHoldableCount, maxCapacity))
    print("========================================")

    if currentHoldableCount >= maxCapacity then
        print("!!! คำเตือน: ช่องเก็บของเต็มแล้ว !!!")
    end
end]]


-- (ทางเลือก) ถ้าต้องการให้มันเช็คทุกๆ 30 วินาที ให้เอา comment ข้างล่างออก
--[[```
while task.wait(30) do
    checkInventoryStatus()
end
--]]

-- ===== ส่วน Setup และโหลด Modules (ทำครั้งเดียว) =====

-- โหลด Module ที่จำเป็น
local ItemModule = require(game:GetService("ReplicatedStorage").Item_Module)
local GrowableData = require(game:GetService("ReplicatedStorage").Data.GrowableData)

-- สร้างตาราง Cache สำหรับเก็บผลลัพธ์
local fruitCheckCache = {}

-- ===== ส่วนฟังก์ชัน Helpers (นำโค้ดที่ดีที่สุดมารวมกัน) =====

--- ฟังก์ชันตรวจสอบว่าพืชมีผลหรือไม่ (ใช้ Cache)
function canPlantHaveFruit(plantName)
    if fruitCheckCache[plantName] ~= nil then
        return fruitCheckCache[plantName]
    end

    local fakePlant = Instance.new("Model")
    fakePlant.Name = plantName
    
    local plantData = GrowableData.GetDataForPlant(nil, fakePlant)
    
    fakePlant:Destroy()
    
    local hasFruit = (plantData and plantData.GrowFruitTime) and true or false
    fruitCheckCache[plantName] = hasFruit
    return hasFruit
end


-- ===== ส่วนการทำงานหลัก (Main Logic) =====

print("--- กำลังวิเคราะห์ข้อมูลพืชทั้งหมดในเกม ---")

-- 1. ดึงรายชื่อพืชทั้งหมดออกมา
local allPlantData = ItemModule.Return_All_Data()

-- 2. วนลูปเพื่อวิเคราะห์และแสดงผลแต่ละชนิด
for _, dataRow in ipairs(allPlantData) do
    local plantName = dataRow[1]
    
    if plantName then
        -- 3. เรียกใช้ฟังก์ชัน helpers ของเราเพื่อดึงข้อมูล
        local hasFruit = canPlantHaveFruit(plantName)
        local plantInfo = {Weight = dataRow[2], Price = dataRow[3]}
        
        -- 4. แปลงผลลัพธ์เป็นข้อความที่อ่านง่าย
        local fruitStatus = hasFruit and "มีผล" or "ไม่มีผล"
        
        -- 5. พิมพ์ข้อมูลสรุปออกมาในรูปแบบที่สวยงาม
        print(string.format("ชื่อ: %-20s | น้ำหนัก: %-7s | ราคา: %-7s | สถานะ: %s", 
            plantName, 
            tostring(plantInfo.Weight), 
            tostring(plantInfo.Price), 
            fruitStatus
        ))
    end
end

print("--- การวิเคราะห์เสร็จสิ้น ---")





local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer or Players.PlayerAdded:Wait()

local myFarm
for _, Farm in ipairs(workspace.Farm:GetChildren()) do
    if Farm.Important.Data.Owner.Value == LocalPlayer.Name then
        myFarm = Farm
    end
end

print(#(myFarm.Important.Plants_Physical:GetChildren()))
for _, v in ipairs(myFarm.Important.Plants_Physical:GetChildren()) do
    ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("Remove_Item"):FireServer(v.Fruits:FindFirstChildOfClass("Model"))
end
